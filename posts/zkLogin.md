---

title: 'Research: zkLogin, Privacy-Preserving Blockchain Authentication with Existing Credentials'

date: '2025-10-15'

category: 'cryptography'

---

![image](https://raw.githubusercontent.com/tain030/blog-post/main/images/zkLogin.webp)

### TLDR;

- zkLogin은 Google·Facebook 같은 기존 OpenID 계정으로 **추가 신뢰 주체 없이** 블록체인 트랜잭션을 서명할 수 있게 하는 메커니즘이다.
    
- 핵심은 OAuth 로그인 과정에 **임시 블록체인 키를 삽입**하고, 이를 **JWT + 영지식 증명(ZK proof)** 으로 검증하는 구조다.
    
- 사용자는 개인 키나 니모닉을 직접 관리하지 않아도 되며, 민감한 신원 정보는 블록체인에 공개되지 않는다.
    
- JWT의 서명을 일종의 인증서처럼 활용하고, 실제 트랜잭션 서명은 임시 키로 수행한다.
    
- ZK 증명은 한 번 생성하면 여러 트랜잭션에 재사용할 수 있어 비용을 절감한다.
    
- 보안은 OpenID 제공자의 인증 보안과 ZK 증명의 건전성에만 의존하며, 별도의 오라클이나 중개 서버는 필요하지 않다.

---

기존 블록체인 지갑은 사용자가 개인 키를 직접 관리해야 하므로 진입 장벽이 높다. 키나 니모닉을 분실하거나 탈취당하면 자산을 복구할 수 없다. 관리형 지갑 역시 해킹이나 운영 주체의 악의적 행위 또는 운영상의 과실로 붕괴된 사례가 반복되며, 신뢰 문제는 꾸준히 제기되어 왔다.

반면 웹 환경에서는 이미 수십억 명의 사용자가 Google, Facebook 등의 플랫폼 계정을 기반으로 OAuth / OpenID Connect 표준 로그인을 사용하고 있다. 이러한 환경에서 기존 웹 계정을 그대로 블록체인 접근 수단으로 활용하려는 시도는 자연스럽다.

문제는 블록체인이 OAuth 클라이언트 역할을 직접 수행할 수 없다는 점이다. 단순 연동 방식은 필연적으로 새로운 신뢰 주체(오라클, 중개 서버)를 도입하게 되며, 이는 탈중앙 시스템이 추구하는 기본 철학과 충돌한다.

**zkLogin**은 “추가적인 신뢰 주체 없이 기존 OpenID 계정으로 블록체인 로그인이 가능한가”라는 질문에 대해 **JWT와 영지식 증명(ZK proof)** 의 결합이라는 해답을 제시한다. 오늘날 EVM 계열에서도 Account Abstraction이 점차 보편화되고 있으며, 실제로는 각 서비스가 운영하는 relayer를 통해 사용자가 개인 키를 직접 관리하지 않아도 되는 구조가 늘어나고 있다. 그런 의미에서 zkLogin은 반드시 “필수적인 미래”라기보다는, OAuth 기반 인증을 블록체인에 연결하는 하나의 설계 지점으로 볼 수 있다.

그럼에도 불구하고 zkLogin이 OAuth를 블록체인에 통합하는 방식은, 신뢰 모델과 프라이버시 설계 측면에서 충분히 참고할 만한 가치가 있다.

## 개요

zkLogin은 기존 OpenID Connect 로그인 흐름을 그대로 유지하면서, 해당 로그인 결과를 블록체인 주소와 안전하게 연결하는 인증 메커니즘이다. 사용자는 OpenID 제공자(OpenID Provider, OP)를 통해 로그인하고, 이 과정에서 OP가 서명한 JWT(JSON Web Token)를 발급받는다. zkLogin은 이 JWT를 그대로 온체인에 공개하지 않고, 영지식 증명(ZK proof)을 통해 “유효한 JWT를 보유하고 있다”는 사실만을 증명한다.

이 과정에서 사용자는 로그인 세션마다 임시 키 쌍을 생성하고, 해당 공개 키를 nonce 형태로 JWT에 포함시킨다. 이후 트랜잭션은 이 임시 개인 키로 서명되며, 체인은 ZK 증명과 함께 제출된 임시 서명을 검증한다. 이로써 사용자는 장기 개인 키나 시드 문구를 직접 관리하지 않아도 된다.

zkLogin 주소는 일반적인 공개 키 기반 주소와 달리, JWT의 식별 정보(`sub`, `iss`, `aud`)와 사용자별 salt를 해시하여 파생된다. salt는 OAuth 계정과 온체인 주소 사이의 직접적인 연결을 끊기 위한 값으로, 이를 통해 외부 관찰자는 주소로부터 사용자의 실제 웹 계정을 추론할 수 없다. 이 구조 덕분에 zkLogin은 기존 웹 로그인 수준의 사용자 경험을 제공하면서도, 온체인에서는 강한 프라이버시와 위조 불가능성을 동시에 달성한다.

## 아키텍처

zkLogin 시스템에는 세 가지 주요 주체가 존재한다.

1. **애플리케이션 프런트엔드**  
    zkLogin을 지원하는 지갑 또는 프런트엔드 애플리케이션을 의미한다. 임시 개인 키를 저장하고, OAuth 로그인 흐름을 트리거하며, zkLogin 트랜잭션을 생성·서명하는 역할을 담당한다.
    
2. **솔트 백업 서비스**
    사용자별 고유 `user_salt`를 반환하는 백엔드 서비스이다. 실제 구현에서는 브라우저/모바일 로컬 저장 또는 별도 백업 전략을 섞어 쓰는 것을 권장하며, 솔트 관리에 대한 다른 전략은 Sui 공식 문서의 통합 가이드를 참고할 수 있다.
    
3. **ZK 증명 서비스**  
    JWT, JWT 무작위성, 사용자 솔트, 최대 에포크를 입력으로 받아 영지식 증명을 생성하는 백엔드 서비스이다. 생성된 증명은 임시 서명과 함께 zkLogin 트랜잭션으로 온체인에 제출된다.

![image](https://raw.githubusercontent.com/tain030/blog-post/main/images/zkLogin-1.png)

(**0단계**)  
zkLogin은 Groth16 zkSNARK를 사용하며, 이에 따라 회로에 연결된 구조화된 공통 참조 문자열(CRS)을 한 번 생성해야 한다. Sui Authority는 이 CRS를 기반으로 검증 키를 생성하며, 이 과정은 별도의 ceremony를 통해 수행된다.

(**1–3단계**)  
사용자는 OpenID 제공자(OP)에 로그인해 nonce가 포함된 JWT를 발급받는다. 이를 위해 사용자는 임시 키쌍 `(eph_sk, eph_pk)`를 생성하고, 만료 에포크(`max_epoch`)와 무작위성(`jwt_randomness`)을 포함해 `eph_pk`를 nonce에 삽입한다. OAuth 로그인 흐름이 완료되면 애플리케이션의 리디렉션 URL을 통해 JWT를 획득한다.

(**4–5단계**)  
애플리케이션 프런트엔드는 JWT를 솔트 서비스로 전송한다. 솔트 서비스는 JWT를 검증한 뒤 `iss`, `aud`, `sub`를 기준으로 사용자에게 고유한 `user_salt`를 반환한다.

(**6–7단계**)  
사용자는 JWT, 사용자 솔트, 임시 공개 키, JWT 무작위성, 그리고 키 발행 기준 필드(예: `sub`)를 ZK 증명 서비스로 전달한다. 증명 서비스는 이를 비공개 입력으로 받아 다음 조건을 만족함을 증명한다.
- nonce가 정의된 규칙에 따라 올바르게 파생되었는지
- 키 발행 값이 JWT의 해당 필드와 일치하는지
- JWT가 OP의 RSA 공개 키로 올바르게 서명되었는지
- 파생된 주소가 키 클레임 값과 사용자 솔트에 대응되는지

(**8단계**)  
애플리케이션은 유효한 JWT가 있는 한, `iss`, `aud`, `sub`를 기반으로 사용자 주소를 독립적으로 계산할 수 있다.

(**9–10단계**)  
임시 개인 키로 트랜잭션에 서명하고, 임시 서명과 ZK 증명, 기타 입력을 함께 Sui 네트워크에 제출한다.

(**온체인 이후**)  
Sui 검증자는 합의된 스토리지에 저장된 provider JWK를 기준으로 ZK 증명과 임시 서명을 검증한다.

## 핵심 메커니즘

zkLogin 아키텍처에서 가장 중요한 보안 요소는 **salt 서버가 사용하는 마스터 시드(master seed)** 이다. 이 마스터 시드는 JWT의 식별 정보로부터 사용자별 `user_salt`를 파생하는 데 사용되며, 이 매핑의 신뢰성과 프라이버시는 마스터 시드의 비밀성에 전적으로 의존한다.

salt 서버 설계의 목표는 명확하다. 첫째, 마스터 시드는 충분히 안전한 방식으로 생성되어야 한다. 둘째, Mysten Labs 내부의 어떤 개인도 이 시드를 알 수 없어야 한다. 셋째, 서비스 운영 중에도 외부 공격이나 클라우드 환경의 사이드 채널을 통해 시드가 유출되어서는 안 된다. 이 조건이 충족되어야만 JWT에서 온체인 주소로의 해시 매핑이 신뢰 가능하다고 말할 수 있다.

이론적으로는 HSM이나 TPM과 같은 전용 보안 하드웨어 안에서 모든 해시 연산을 수행하는 것이 가장 안전하다. 그러나 마스터 시드를 단일 하드웨어에 고정하면, 해당 장비가 곧 시스템 전체의 단일 장애 지점이 된다. 장비 접근이 불가능해지는 순간, 마스터 시드는 영구적으로 복구할 수 없게 된다. zkLogin의 경우 시드가 영구적이고 교체 불가능하다는 특성상, 이러한 위험은 감당하기 어렵다.

이에 따라 zkLogin은 절대적인 하드웨어 보안 대신, **신뢰할 수 있는 컴퓨팅 환경(Trusted Compute Environment, TEE)** 을 선택했다. 구체적으로는 AWS EC2의 **Nitro Enclaves**를 사용해 salt 서버를 격리된 실행 환경 안에서 운영한다. 이 환경에서는 컨테이너 단위의 무결성 검증(attestation)이 가능하고, 네트워크 접근 역시 엄격히 제한된다.

마스터 시드는 Nitro Enclave 내부에서 난수를 기반으로 한 번만 생성된다. 생성된 시드는 암호화된 형태로 비밀 저장소에 보관되며, 해당 저장소는 오직 Enclave의 아이덴티티만 접근할 수 있도록 설정된다. 관리자조차 평문 시드를 확인할 수 없으며, 키는 복구를 대비해 분할 저장된다. Enclave가 실행 중일 때만 시드는 메모리에 평문으로 로드되며, 이는 동일 호스트 내 접근을 원천적으로 차단하는 격리 환경의 보안에 의존한다.

네트워크 측면에서도 최소 권한 원칙이 적용된다. salt 서버 Enclave는 vsock 프록시를 통해 단일 애플리케이션 포트로 들어오는 요청만 수신하며, 외부로는 JWT 검증을 위한 OAuth 제공자와 관측용 게이트웨이로의 트래픽만 허용된다. 그 외 모든 네트워크 접근은 차단된다. 이 구조를 통해 salt 서버는 사용자별 salt를 안전하게 계산할 수 있고, 동시에 마스터 시드는 외부에 노출되지 않는다.

결과적으로 zkLogin의 아키텍처와 워크플로우는 “JWT → ZK 증명 → 임시 서명 → 온체인 검증”이라는 사용자 흐름을 가능하게 하면서, 그 이면에서는 salt 서버와 마스터 시드가 강력하게 보호되는 구조를 이룬다. 이 분리 덕분에 사용자 경험은 단순해지지만, 보안의 핵심은 좁고 통제된 영역에 집중된다.

## 한계점 및 향후 과제

zkLogin은 OP의 서명과 임시 키 비밀 없이는 유효한 서명을 생성할 수 없다는 점에서 위조 불가능성을 보장한다. 또한 영지식 증명을 통해 개인정보와 식별자는 체인에 노출되지 않는다. 다만 보안 모델은 SNARK의 안전성과 OP의 정직한 인증을 가정하며, OP 키가 유출되는 경우 zkLogin 자체로는 이를 방어할 수 없다.

또한 zkLogin은 대규모 증명 회로로 인해 증명 비용이 높다. 모바일이나 브라우저 환경에서 직접 증명 생성은 현실적으로 어렵다. 더불어 보안이 OpenID 제공자에 의존하며, SNARK 검증과 OP 키 오라클을 지원하는 체인에서만 적용 가능하다. `user_salt` 관리 역시 사용자 경험 측면에서 여전히 해결해야 할 과제로 남아 있다.

zkLogin은 단순히 소셜 로그인을 위한 기술은 아니다. 현재 구조에서 OAuth 대신 패스키를 사용할 수도 있으나, 이 방식이 패스키를 활용하는 최적의 설계인지는 별도의 검토가 필요하다.

## 요약

zkLogin은 기존 OpenID 계정을 블록체인 서명 수단으로 확장한 새로운 서명 방식이다. 임시 키를 OAuth 로그인 과정에 결합하고, JWT의 유효성을 영지식 증명으로 검증함으로써 프라이버시를 유지한 채 암호학적 보안을 달성한다. 이 설계는 사용자 경험을 크게 개선하면서도, 탈중앙성과 개인정보 보호를 동시에 유지한다.
